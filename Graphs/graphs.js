//вершины
//ребра (однонаправленные, двунаправленные)
// граф можно представить в виде матрицы смежности

const graph = {};

graph.a = ['b','c']
graph.b = ['f']
graph.c = ['d','e']
graph.d = ['f']
graph.e = ['f']
graph.f = ['g']

// Этот алгоритм:
// 1) Решает задачу поиска пути в графу, существует ли такой путь
// 2) Находит путь за минимальное кол-во шагов
function breathSearch(graph,start,end){
    //очередь
    let queue=[];
    //   В очередь сразу добавляем стартовую вершину(start, в данном случае "a")
    queue.push(start)

  //   Крутим цикл while пока в очереди есть хотя бы один элемент
    while(queue.length >0){
        // Из начала очереди достаем текущую вершину
        const current = queue.shift()
        // Если по текущей вершине в графе ничего не находится, то присваиваем этой вершине пустой массив
        
        if(!graph[current]){
            graph[current] = []
        }
        // Если в графе по текущей вершине массив содержит конечную точку, то мы завершаем выполнение
        // программы и возвращаем true. То есть на данном этапе мы обошли весь граф и пришли
        // к пункту назначения.

        if(graph[current].includes(end)){
            return true;
        } else {
            // Если это условие не отработало, то мы должны добавить в очередь новые вершины.
            //   Поэтому разворачиваем то, что уже находится в очереди в массив и в конец разворачиваем массив
            //   который лежит в графе по текущей вершине.
            queue=[...queue,...graph[current]];
        }
    }
    return false;
}

console.log(breathSearch(graph,'a','g'))