// Алгоритм Дейкстры - для поиска кратчайшего пути в графе
// учитывается длинна (вес графа)

const graph = {};

  // 1) --------------------------------------------------
  // costs - объект где мы будем хранить кратчайшие пути
  graph.a = { b: 2, c: 1 };
  graph.b = { f: 7 };
  graph.c = { d: 5, e: 2 };
  graph.d = { f: 2 };
  graph.e = { f: 1 };
  graph.f = { g: 1 };
  graph.g = {};


function shortPath(graph,start,end){
    // таблица с кратчайшим путем
    const costs = {};
    // узлы которые уже првоерили
    const processed = [];
    // соседние вершины рассматриваемого узла
    let neighbors = {};

  // Мы должны заполнить таблицу, заполнить те вершины в которые мы можем добраться из
  // стартовой точки значениями, а все остальные мы должны заполнить бесконечно каким-то большим
  // числом.
  // Поэтому у нашего графа получаем список ключей(это будут все вершины) и итерируемся по ним.
    Object.keys(graph).forEach(node=>{
        if(node!==start){
            // Получаем значение (вес) вершины либо B либо C
            let value = graph[start][node];
            costs[node]= value || 1000000000
        }
    })
    let node = findNodeLowestCost(costs, processed)

    while (node) {
        // На кажой итерации получаем стоимость текущей вершины
        const cost = costs[node];
        // Те узлы в которые мы можем попасть из этой вершины мы присваиваем в neighbors
        neighbors = graph[node];
        Object.keys(neighbors).forEach((neighbor) => {
          // Высчитываем новую стоимость
          let newCost = cost + neighbors[neighbor];
          //Перезаписываем в таблице значение если новая стоимость меньше
          if (newCost < costs[neighbor]) {
            costs[neighbor] = newCost;
          }
        });
        //  Добавляем вершину в массив уже обработанных вершин, после чего при поиске вершин с минимальной
        //  стоимостью эта вершина уже учитываться не будет.
        processed.push(node);
        // И ищем новую вершину.
        node = findNodeLowestCost(costs, processed);
      }
      // Возврашаем объект, который хранит  самые кратчайшие пути.
      console.log('costs',costs)
      return costs;
}

// 2) --------------------------------------------------
// На этом этапе необходимо найти вершину, в которую мы можем попасть из точки A
// и путь в которую самый короткий. Название ф-ии "Найти узел с минимальной стоимостью"
function findNodeLowestCost(costs,processed){
  // lowestCost - будет хранить минимальное значение, по умолчанию 1000000000
  let lowestCost = 1000000000;
  // lowestNode - нода, которую мы будем возвращать с минимальным значением
  let lowestNode;
  // Теперь необходимо проитерироваться по ключам объекта в котором мы храним стоимость путей.
  Object.keys(costs).forEach((node) => {
    // Получим стоимость текущей ноды
    let cost = costs[node];
    // Если стоимость, которую мы получили меньше чем минимальная стоимость, которую мы определили в самом начале
    // и вершина которую мы рассматриваем на текущей итерации не находится в массиве обработанных вершин.
    // То есть мы сравниваем стоимость - если она меншьше и если узел еще не обработан, то мы обновляем переменные.
    if (cost < lowestCost && !processed.includes(node)) {
      // Если условие выполнилось, то мы нашли объект у которого путь короче.
      // Соотвественно мы перезаписываем минимальную стоимость на  ту, которую мы сейчас нашли на этой итерации
      // и заменяем ноду.
      lowestCost = cost;
      lowestNode = node;
    }
  });
  //   Возврашаем вершину с минимальной стоимостью.
  return lowestNode;
}


shortPath(graph,'a','g')